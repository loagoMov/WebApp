import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import * as core from "../../../../core/index.js";
import * as Management from "../../../index.js";
import { AuthenticationMethods } from "../resources/authenticationMethods/client/Client.js";
import { Authenticators } from "../resources/authenticators/client/Client.js";
import { ConnectedAccounts } from "../resources/connectedAccounts/client/Client.js";
import { Enrollments } from "../resources/enrollments/client/Client.js";
import { FederatedConnectionsTokensets } from "../resources/federatedConnectionsTokensets/client/Client.js";
import { Identities } from "../resources/identities/client/Client.js";
import { Logs } from "../resources/logs/client/Client.js";
import { Multifactor } from "../resources/multifactor/client/Client.js";
import { Organizations } from "../resources/organizations/client/Client.js";
import { Permissions } from "../resources/permissions/client/Client.js";
import { RiskAssessments } from "../resources/riskAssessments/client/Client.js";
import { Roles } from "../resources/roles/client/Client.js";
import { RefreshToken } from "../resources/refreshToken/client/Client.js";
import { Sessions } from "../resources/sessions/client/Client.js";
export declare namespace Users {
    interface Options extends BaseClientOptions {
    }
    interface RequestOptions extends BaseRequestOptions {
    }
}
export declare class Users {
    protected readonly _options: Users.Options;
    protected _authenticationMethods: AuthenticationMethods | undefined;
    protected _authenticators: Authenticators | undefined;
    protected _connectedAccounts: ConnectedAccounts | undefined;
    protected _enrollments: Enrollments | undefined;
    protected _federatedConnectionsTokensets: FederatedConnectionsTokensets | undefined;
    protected _identities: Identities | undefined;
    protected _logs: Logs | undefined;
    protected _multifactor: Multifactor | undefined;
    protected _organizations: Organizations | undefined;
    protected _permissions: Permissions | undefined;
    protected _riskAssessments: RiskAssessments | undefined;
    protected _roles: Roles | undefined;
    protected _refreshToken: RefreshToken | undefined;
    protected _sessions: Sessions | undefined;
    constructor(_options: Users.Options);
    get authenticationMethods(): AuthenticationMethods;
    get authenticators(): Authenticators;
    get connectedAccounts(): ConnectedAccounts;
    get enrollments(): Enrollments;
    get federatedConnectionsTokensets(): FederatedConnectionsTokensets;
    get identities(): Identities;
    get logs(): Logs;
    get multifactor(): Multifactor;
    get organizations(): Organizations;
    get permissions(): Permissions;
    get riskAssessments(): RiskAssessments;
    get roles(): Roles;
    get refreshToken(): RefreshToken;
    get sessions(): Sessions;
    /**
     * Retrieve details of users. It is possible to:
     *
     * - Specify a search criteria for users
     * - Sort the users to be returned
     * - Select the fields to be returned
     * - Specify the number of users to retrieve per page and the page index
     *  <!-- only v3 is available -->
     * The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a>
     *
     * <a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a>
     *
     * Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.
     *
     * Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.
     *
     * @param {Management.ListUsersRequestParameters} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     * @throws {@link Management.ServiceUnavailableError}
     *
     * @example
     *     await client.users.list({
     *         page: 1,
     *         per_page: 1,
     *         include_totals: true,
     *         sort: "sort",
     *         connection: "connection",
     *         fields: "fields",
     *         include_fields: true,
     *         q: "q",
     *         search_engine: "v1",
     *         primary_order: true
     *     })
     */
    list(request?: Management.ListUsersRequestParameters, requestOptions?: Users.RequestOptions): Promise<core.Page<Management.UserResponseSchema, Management.ListUsersOffsetPaginatedResponseContent>>;
    /**
     * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
     *
     * Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.
     *
     * @param {Management.CreateUserRequestContent} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.ConflictError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.create({
     *         connection: "connection"
     *     })
     */
    create(request: Management.CreateUserRequestContent, requestOptions?: Users.RequestOptions): core.HttpResponsePromise<Management.CreateUserResponseContent>;
    private __create;
    /**
     * Find users by email. If Auth0 is the identity provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it.
     *
     * For example, if you register a user as JohnSmith@example.com, Auth0 saves the user's email as johnsmith@example.com.
     *
     * Therefore, when using this endpoint, make sure that you are searching for users via email addresses using the correct case.
     *
     * @param {Management.ListUsersByEmailRequestParameters} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.listUsersByEmail({
     *         fields: "fields",
     *         include_fields: true,
     *         email: "email"
     *     })
     */
    listUsersByEmail(request: Management.ListUsersByEmailRequestParameters, requestOptions?: Users.RequestOptions): core.HttpResponsePromise<Management.UserResponseSchema[]>;
    private __listUsersByEmail;
    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     *
     * @param {string} id - ID of the user to retrieve.
     * @param {Management.GetUserRequestParameters} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.get("id", {
     *         fields: "fields",
     *         include_fields: true
     *     })
     */
    get(id: string, request?: Management.GetUserRequestParameters, requestOptions?: Users.RequestOptions): core.HttpResponsePromise<Management.GetUserResponseContent>;
    private __get;
    /**
     * Delete a user by user ID. This action cannot be undone. For Auth0 Dashboard instructions, see <a href="https://auth0.com/docs/manage-users/user-accounts/delete-users">Delete Users</a>.
     *
     * @param {string} id - ID of the user to delete.
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.delete("id")
     */
    delete(id: string, requestOptions?: Users.RequestOptions): core.HttpResponsePromise<void>;
    private __delete;
    /**
     * Update a user.
     *
     * These are the attributes that can be updated at the root level:
     *
     * <ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul>
     *
     * Some considerations:
     * <ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the "Unblock a user" endpoint from the "User Blocks" API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul>
     *
     * <h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ "email_verified": true }</code></pre>
     *
     * <h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ "user_metadata" : { "profileCode": 1479 } }</code></pre>
     *
     * To add the field <code>addresses</code> the body to send should be:
     * <pre><code>{ "user_metadata" : { "addresses": {"work_address": "100 Industrial Way"} }}</code></pre>
     *
     * The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     *   "user_metadata": {
     *     "profileCode": 1479,
     *     "addresses": { "work_address": "100 Industrial Way" }
     *   }
     * }</code></pre>
     *
     * <h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>"home_address": "742 Evergreen Terrace"</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   "user_metadata": {
     *     "addresses": {
     *       "work_address": "100 Industrial Way",
     *       "home_address": "742 Evergreen Terrace"
     *     }
     *   }
     * }</code></pre>
     *
     * The modified object ends up with the following <code>user_metadata</code> property:
     * <pre><code>{
     *   "user_metadata": {
     *     "profileCode": 1479,
     *     "addresses": {
     *       "work_address": "100 Industrial Way",
     *       "home_address": "742 Evergreen Terrace"
     *     }
     *   }
     * }</code></pre>
     *
     * @param {string} id - ID of the user to update.
     * @param {Management.UpdateUserRequestContent} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.update("id")
     */
    update(id: string, request?: Management.UpdateUserRequestContent, requestOptions?: Users.RequestOptions): core.HttpResponsePromise<Management.UpdateUserResponseContent>;
    private __update;
    /**
     * Remove an existing multi-factor authentication (MFA) <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">recovery code</a> and generate a new one. If a user cannot access the original device or account used for MFA enrollment, they can use a recovery code to authenticate.
     *
     * @param {string} id - ID of the user to regenerate a multi-factor authentication recovery code for.
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     *
     * @example
     *     await client.users.regenerateRecoveryCode("id")
     */
    regenerateRecoveryCode(id: string, requestOptions?: Users.RequestOptions): core.HttpResponsePromise<Management.RegenerateUsersRecoveryCodeResponseContent>;
    private __regenerateRecoveryCode;
    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     *
     * @param {string} id - ID of the user.
     * @param {Management.RevokeUserAccessRequestContent} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.revokeAccess("id")
     */
    revokeAccess(id: string, request?: Management.RevokeUserAccessRequestContent, requestOptions?: Users.RequestOptions): core.HttpResponsePromise<void>;
    private __revokeAccess;
    protected _getAuthorizationHeader(): Promise<string>;
}
