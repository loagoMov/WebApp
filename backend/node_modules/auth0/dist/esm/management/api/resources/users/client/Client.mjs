// This file was auto-generated by Fern from our API Definition.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as environments from "../../../../environments.mjs";
import * as core from "../../../../core/index.mjs";
import * as Management from "../../../index.mjs";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.mjs";
import * as errors from "../../../../errors/index.mjs";
import { AuthenticationMethods } from "../resources/authenticationMethods/client/Client.mjs";
import { Authenticators } from "../resources/authenticators/client/Client.mjs";
import { ConnectedAccounts } from "../resources/connectedAccounts/client/Client.mjs";
import { Enrollments } from "../resources/enrollments/client/Client.mjs";
import { FederatedConnectionsTokensets } from "../resources/federatedConnectionsTokensets/client/Client.mjs";
import { Identities } from "../resources/identities/client/Client.mjs";
import { Logs } from "../resources/logs/client/Client.mjs";
import { Multifactor } from "../resources/multifactor/client/Client.mjs";
import { Organizations } from "../resources/organizations/client/Client.mjs";
import { Permissions } from "../resources/permissions/client/Client.mjs";
import { RiskAssessments } from "../resources/riskAssessments/client/Client.mjs";
import { Roles } from "../resources/roles/client/Client.mjs";
import { RefreshToken } from "../resources/refreshToken/client/Client.mjs";
import { Sessions } from "../resources/sessions/client/Client.mjs";
export class Users {
    constructor(_options) {
        this._options = _options;
    }
    get authenticationMethods() {
        var _a;
        return ((_a = this._authenticationMethods) !== null && _a !== void 0 ? _a : (this._authenticationMethods = new AuthenticationMethods(this._options)));
    }
    get authenticators() {
        var _a;
        return ((_a = this._authenticators) !== null && _a !== void 0 ? _a : (this._authenticators = new Authenticators(this._options)));
    }
    get connectedAccounts() {
        var _a;
        return ((_a = this._connectedAccounts) !== null && _a !== void 0 ? _a : (this._connectedAccounts = new ConnectedAccounts(this._options)));
    }
    get enrollments() {
        var _a;
        return ((_a = this._enrollments) !== null && _a !== void 0 ? _a : (this._enrollments = new Enrollments(this._options)));
    }
    get federatedConnectionsTokensets() {
        var _a;
        return ((_a = this._federatedConnectionsTokensets) !== null && _a !== void 0 ? _a : (this._federatedConnectionsTokensets = new FederatedConnectionsTokensets(this._options)));
    }
    get identities() {
        var _a;
        return ((_a = this._identities) !== null && _a !== void 0 ? _a : (this._identities = new Identities(this._options)));
    }
    get logs() {
        var _a;
        return ((_a = this._logs) !== null && _a !== void 0 ? _a : (this._logs = new Logs(this._options)));
    }
    get multifactor() {
        var _a;
        return ((_a = this._multifactor) !== null && _a !== void 0 ? _a : (this._multifactor = new Multifactor(this._options)));
    }
    get organizations() {
        var _a;
        return ((_a = this._organizations) !== null && _a !== void 0 ? _a : (this._organizations = new Organizations(this._options)));
    }
    get permissions() {
        var _a;
        return ((_a = this._permissions) !== null && _a !== void 0 ? _a : (this._permissions = new Permissions(this._options)));
    }
    get riskAssessments() {
        var _a;
        return ((_a = this._riskAssessments) !== null && _a !== void 0 ? _a : (this._riskAssessments = new RiskAssessments(this._options)));
    }
    get roles() {
        var _a;
        return ((_a = this._roles) !== null && _a !== void 0 ? _a : (this._roles = new Roles(this._options)));
    }
    get refreshToken() {
        var _a;
        return ((_a = this._refreshToken) !== null && _a !== void 0 ? _a : (this._refreshToken = new RefreshToken(this._options)));
    }
    get sessions() {
        var _a;
        return ((_a = this._sessions) !== null && _a !== void 0 ? _a : (this._sessions = new Sessions(this._options)));
    }
    /**
     * Retrieve details of users. It is possible to:
     *
     * - Specify a search criteria for users
     * - Sort the users to be returned
     * - Select the fields to be returned
     * - Specify the number of users to retrieve per page and the page index
     *  <!-- only v3 is available -->
     * The <code>q</code> query parameter can be used to get users that match the specified criteria <a href="https://auth0.com/docs/users/search/v3/query-syntax">using query string syntax.</a>
     *
     * <a href="https://auth0.com/docs/users/search/v3">Learn more about searching for users.</a>
     *
     * Read about <a href="https://auth0.com/docs/users/search/best-practices">best practices</a> when working with the API endpoints for retrieving users.
     *
     * Auth0 limits the number of users you can return. If you exceed this threshold, please redefine your search, use the <a href="https://auth0.com/docs/api/management/v2#!/Jobs/post_users_exports">export job</a>, or the <a href="https://auth0.com/docs/extensions/user-import-export">User Import / Export</a> extension.
     *
     * @param {Management.ListUsersRequestParameters} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     * @throws {@link Management.ServiceUnavailableError}
     *
     * @example
     *     await client.users.list({
     *         page: 1,
     *         per_page: 1,
     *         include_totals: true,
     *         sort: "sort",
     *         connection: "connection",
     *         fields: "fields",
     *         include_fields: true,
     *         q: "q",
     *         search_engine: "v1",
     *         primary_order: true
     *     })
     */
    list() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const list = core.HttpResponsePromise.interceptFunction((request) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
                const { page = 0, per_page: perPage = 50, include_totals: includeTotals = true, sort, connection, fields, include_fields: includeFields, q, search_engine: searchEngine, primary_order: primaryOrder, } = request;
                const _queryParams = {};
                if (page !== undefined) {
                    _queryParams["page"] = (_a = page === null || page === void 0 ? void 0 : page.toString()) !== null && _a !== void 0 ? _a : null;
                }
                if (perPage !== undefined) {
                    _queryParams["per_page"] = (_b = perPage === null || perPage === void 0 ? void 0 : perPage.toString()) !== null && _b !== void 0 ? _b : null;
                }
                if (includeTotals !== undefined) {
                    _queryParams["include_totals"] = (_c = includeTotals === null || includeTotals === void 0 ? void 0 : includeTotals.toString()) !== null && _c !== void 0 ? _c : null;
                }
                if (sort !== undefined) {
                    _queryParams["sort"] = sort;
                }
                if (connection !== undefined) {
                    _queryParams["connection"] = connection;
                }
                if (fields !== undefined) {
                    _queryParams["fields"] = fields;
                }
                if (includeFields !== undefined) {
                    _queryParams["include_fields"] = (_d = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _d !== void 0 ? _d : null;
                }
                if (q !== undefined) {
                    _queryParams["q"] = q;
                }
                if (searchEngine !== undefined) {
                    _queryParams["search_engine"] = searchEngine;
                }
                if (primaryOrder !== undefined) {
                    _queryParams["primary_order"] = (_e = primaryOrder === null || primaryOrder === void 0 ? void 0 : primaryOrder.toString()) !== null && _e !== void 0 ? _e : null;
                }
                let _headers = mergeHeaders((_f = this._options) === null || _f === void 0 ? void 0 : _f.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader() }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
                const _response = yield ((_g = this._options.fetcher) !== null && _g !== void 0 ? _g : core.fetcher)({
                    url: core.url.join((_j = (_h = (yield core.Supplier.get(this._options.baseUrl))) !== null && _h !== void 0 ? _h : (yield core.Supplier.get(this._options.environment))) !== null && _j !== void 0 ? _j : environments.ManagementEnvironment.Default, "users"),
                    method: "GET",
                    headers: _headers,
                    queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                    timeoutMs: ((_m = (_k = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _k !== void 0 ? _k : (_l = this._options) === null || _l === void 0 ? void 0 : _l.timeoutInSeconds) !== null && _m !== void 0 ? _m : 60) * 1000,
                    maxRetries: (_o = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _o !== void 0 ? _o : (_p = this._options) === null || _p === void 0 ? void 0 : _p.maxRetries,
                    abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                    fetchFn: (_q = this._options) === null || _q === void 0 ? void 0 : _q.fetch,
                });
                if (_response.ok) {
                    return {
                        data: _response.body,
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 400:
                            throw new Management.BadRequestError(_response.error.body, _response.rawResponse);
                        case 401:
                            throw new Management.UnauthorizedError(_response.error.body, _response.rawResponse);
                        case 403:
                            throw new Management.ForbiddenError(_response.error.body, _response.rawResponse);
                        case 429:
                            throw new Management.TooManyRequestsError(_response.error.body, _response.rawResponse);
                        case 503:
                            throw new Management.ServiceUnavailableError(_response.error.body, _response.rawResponse);
                        default:
                            throw new errors.ManagementError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                                rawResponse: _response.rawResponse,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                            rawResponse: _response.rawResponse,
                        });
                    case "timeout":
                        throw new errors.ManagementTimeoutError("Timeout exceeded when calling GET /users.");
                    case "unknown":
                        throw new errors.ManagementError({
                            message: _response.error.errorMessage,
                            rawResponse: _response.rawResponse,
                        });
                }
            }));
            let _offset = (request === null || request === void 0 ? void 0 : request.page) != null ? request === null || request === void 0 ? void 0 : request.page : 0;
            const dataWithRawResponse = yield list(request).withRawResponse();
            return new core.Page({
                response: dataWithRawResponse.data,
                rawResponse: dataWithRawResponse.rawResponse,
                hasNextPage: (response) => { var _a, _b; return ((_a = response === null || response === void 0 ? void 0 : response.users) !== null && _a !== void 0 ? _a : []).length >= ((_b = request === null || request === void 0 ? void 0 : request.per_page) !== null && _b !== void 0 ? _b : 1); },
                getItems: (response) => { var _a; return (_a = response === null || response === void 0 ? void 0 : response.users) !== null && _a !== void 0 ? _a : []; },
                loadPage: (response) => {
                    _offset += (response === null || response === void 0 ? void 0 : response.users) != null ? response.users.length : 1;
                    return list(core.setObjectProperty(request, "page", _offset));
                },
            });
        });
    }
    /**
     * Create a new user for a given <a href="https://auth0.com/docs/connections/database">database</a> or <a href="https://auth0.com/docs/connections/passwordless">passwordless</a> connection.
     *
     * Note: <code>connection</code> is required but other parameters such as <code>email</code> and <code>password</code> are dependent upon the type of connection.
     *
     * @param {Management.CreateUserRequestContent} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.ConflictError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.create({
     *         connection: "connection"
     *     })
     */
    create(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }
    __create(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader() }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : core.fetcher)({
                url: core.url.join((_d = (_c = (yield core.Supplier.get(this._options.baseUrl))) !== null && _c !== void 0 ? _c : (yield core.Supplier.get(this._options.environment))) !== null && _d !== void 0 ? _d : environments.ManagementEnvironment.Default, "users"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1000,
                maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Management.BadRequestError(_response.error.body, _response.rawResponse);
                    case 401:
                        throw new Management.UnauthorizedError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Management.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 409:
                        throw new Management.ConflictError(_response.error.body, _response.rawResponse);
                    case 429:
                        throw new Management.TooManyRequestsError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.ManagementTimeoutError("Timeout exceeded when calling POST /users.");
                case "unknown":
                    throw new errors.ManagementError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Find users by email. If Auth0 is the identity provider (idP), the email address associated with a user is saved in lower case, regardless of how you initially provided it.
     *
     * For example, if you register a user as JohnSmith@example.com, Auth0 saves the user's email as johnsmith@example.com.
     *
     * Therefore, when using this endpoint, make sure that you are searching for users via email addresses using the correct case.
     *
     * @param {Management.ListUsersByEmailRequestParameters} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.listUsersByEmail({
     *         fields: "fields",
     *         include_fields: true,
     *         email: "email"
     *     })
     */
    listUsersByEmail(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__listUsersByEmail(request, requestOptions));
    }
    __listUsersByEmail(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            const { fields, include_fields: includeFields, email } = request;
            const _queryParams = {};
            if (fields !== undefined) {
                _queryParams["fields"] = fields;
            }
            if (includeFields !== undefined) {
                _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
            }
            _queryParams["email"] = email;
            let _headers = mergeHeaders((_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader() }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : core.fetcher)({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.ManagementEnvironment.Default, "users-by-email"),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Management.BadRequestError(_response.error.body, _response.rawResponse);
                    case 401:
                        throw new Management.UnauthorizedError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Management.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 429:
                        throw new Management.TooManyRequestsError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.ManagementTimeoutError("Timeout exceeded when calling GET /users-by-email.");
                case "unknown":
                    throw new errors.ManagementError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Retrieve user details. A list of fields to include or exclude may also be specified. For more information, see <a href="https://auth0.com/docs/manage-users/user-search/retrieve-users-with-get-users-endpoint">Retrieve Users with the Get Users Endpoint</a>.
     *
     * @param {string} id - ID of the user to retrieve.
     * @param {Management.GetUserRequestParameters} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.get("id", {
     *         fields: "fields",
     *         include_fields: true
     *     })
     */
    get(id, request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__get(id, request, requestOptions));
    }
    __get(id_1) {
        return __awaiter(this, arguments, void 0, function* (id, request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            const { fields, include_fields: includeFields } = request;
            const _queryParams = {};
            if (fields !== undefined) {
                _queryParams["fields"] = fields;
            }
            if (includeFields !== undefined) {
                _queryParams["include_fields"] = (_a = includeFields === null || includeFields === void 0 ? void 0 : includeFields.toString()) !== null && _a !== void 0 ? _a : null;
            }
            let _headers = mergeHeaders((_b = this._options) === null || _b === void 0 ? void 0 : _b.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader() }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield ((_c = this._options.fetcher) !== null && _c !== void 0 ? _c : core.fetcher)({
                url: core.url.join((_e = (_d = (yield core.Supplier.get(this._options.baseUrl))) !== null && _d !== void 0 ? _d : (yield core.Supplier.get(this._options.environment))) !== null && _e !== void 0 ? _e : environments.ManagementEnvironment.Default, `users/${core.url.encodePathParam(id)}`),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: ((_h = (_f = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _f !== void 0 ? _f : (_g = this._options) === null || _g === void 0 ? void 0 : _g.timeoutInSeconds) !== null && _h !== void 0 ? _h : 60) * 1000,
                maxRetries: (_j = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _j !== void 0 ? _j : (_k = this._options) === null || _k === void 0 ? void 0 : _k.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_l = this._options) === null || _l === void 0 ? void 0 : _l.fetch,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Management.BadRequestError(_response.error.body, _response.rawResponse);
                    case 401:
                        throw new Management.UnauthorizedError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Management.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Management.NotFoundError(_response.error.body, _response.rawResponse);
                    case 429:
                        throw new Management.TooManyRequestsError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.ManagementTimeoutError("Timeout exceeded when calling GET /users/{id}.");
                case "unknown":
                    throw new errors.ManagementError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Delete a user by user ID. This action cannot be undone. For Auth0 Dashboard instructions, see <a href="https://auth0.com/docs/manage-users/user-accounts/delete-users">Delete Users</a>.
     *
     * @param {string} id - ID of the user to delete.
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.delete("id")
     */
    delete(id, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
    }
    __delete(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader() }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : core.fetcher)({
                url: core.url.join((_d = (_c = (yield core.Supplier.get(this._options.baseUrl))) !== null && _c !== void 0 ? _c : (yield core.Supplier.get(this._options.environment))) !== null && _d !== void 0 ? _d : environments.ManagementEnvironment.Default, `users/${core.url.encodePathParam(id)}`),
                method: "DELETE",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1000,
                maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
            });
            if (_response.ok) {
                return { data: undefined, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Management.BadRequestError(_response.error.body, _response.rawResponse);
                    case 401:
                        throw new Management.UnauthorizedError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Management.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 429:
                        throw new Management.TooManyRequestsError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.ManagementTimeoutError("Timeout exceeded when calling DELETE /users/{id}.");
                case "unknown":
                    throw new errors.ManagementError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Update a user.
     *
     * These are the attributes that can be updated at the root level:
     *
     * <ul>
     *     <li>app_metadata</li>
     *     <li>blocked</li>
     *     <li>email</li>
     *     <li>email_verified</li>
     *     <li>family_name</li>
     *     <li>given_name</li>
     *     <li>name</li>
     *     <li>nickname</li>
     *     <li>password</li>
     *     <li>phone_number</li>
     *     <li>phone_verified</li>
     *     <li>picture</li>
     *     <li>username</li>
     *     <li>user_metadata</li>
     *     <li>verify_email</li>
     * </ul>
     *
     * Some considerations:
     * <ul>
     *     <li>The properties of the new object will replace the old ones.</li>
     *     <li>The metadata fields are an exception to this rule (<code>user_metadata</code> and <code>app_metadata</code>). These properties are merged instead of being replaced but be careful, the merge only occurs on the first level.</li>
     *     <li>If you are updating <code>email</code>, <code>email_verified</code>, <code>phone_number</code>, <code>phone_verified</code>, <code>username</code> or <code>password</code> of a secondary identity, you need to specify the <code>connection</code> property too.</li>
     *     <li>If you are updating <code>email</code> or <code>phone_number</code> you can specify, optionally, the <code>client_id</code> property.</li>
     *     <li>Updating <code>email_verified</code> is not supported for enterprise and passwordless sms connections.</li>
     *     <li>Updating the <code>blocked</code> to <code>false</code> does not affect the user's blocked state from an excessive amount of incorrectly provided credentials. Use the "Unblock a user" endpoint from the "User Blocks" API to change the user's state.</li>
     *     <li>Supported attributes can be unset by supplying <code>null</code> as the value.</li>
     * </ul>
     *
     * <h5>Updating a field (non-metadata property)</h5>
     * To mark the email address of a user as verified, the body to send should be:
     * <pre><code>{ "email_verified": true }</code></pre>
     *
     * <h5>Updating a user metadata root property</h5>Let's assume that our test user has the following <code>user_metadata</code>:
     * <pre><code>{ "user_metadata" : { "profileCode": 1479 } }</code></pre>
     *
     * To add the field <code>addresses</code> the body to send should be:
     * <pre><code>{ "user_metadata" : { "addresses": {"work_address": "100 Industrial Way"} }}</code></pre>
     *
     * The modified object ends up with the following <code>user_metadata</code> property:<pre><code>{
     *   "user_metadata": {
     *     "profileCode": 1479,
     *     "addresses": { "work_address": "100 Industrial Way" }
     *   }
     * }</code></pre>
     *
     * <h5>Updating an inner user metadata property</h5>If there's existing user metadata to which we want to add  <code>"home_address": "742 Evergreen Terrace"</code> (using the <code>addresses</code> property) we should send the whole <code>addresses</code> object. Since this is a first-level object, the object will be merged in, but its own properties will not be. The body to send should be:
     * <pre><code>{
     *   "user_metadata": {
     *     "addresses": {
     *       "work_address": "100 Industrial Way",
     *       "home_address": "742 Evergreen Terrace"
     *     }
     *   }
     * }</code></pre>
     *
     * The modified object ends up with the following <code>user_metadata</code> property:
     * <pre><code>{
     *   "user_metadata": {
     *     "profileCode": 1479,
     *     "addresses": {
     *       "work_address": "100 Industrial Way",
     *       "home_address": "742 Evergreen Terrace"
     *     }
     *   }
     * }</code></pre>
     *
     * @param {string} id - ID of the user to update.
     * @param {Management.UpdateUserRequestContent} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.update("id")
     */
    update(id, request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__update(id, request, requestOptions));
    }
    __update(id_1) {
        return __awaiter(this, arguments, void 0, function* (id, request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader() }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : core.fetcher)({
                url: core.url.join((_d = (_c = (yield core.Supplier.get(this._options.baseUrl))) !== null && _c !== void 0 ? _c : (yield core.Supplier.get(this._options.environment))) !== null && _d !== void 0 ? _d : environments.ManagementEnvironment.Default, `users/${core.url.encodePathParam(id)}`),
                method: "PATCH",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1000,
                maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Management.BadRequestError(_response.error.body, _response.rawResponse);
                    case 401:
                        throw new Management.UnauthorizedError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Management.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Management.NotFoundError(_response.error.body, _response.rawResponse);
                    case 429:
                        throw new Management.TooManyRequestsError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.ManagementTimeoutError("Timeout exceeded when calling PATCH /users/{id}.");
                case "unknown":
                    throw new errors.ManagementError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Remove an existing multi-factor authentication (MFA) <a href="https://auth0.com/docs/secure/multi-factor-authentication/reset-user-mfa">recovery code</a> and generate a new one. If a user cannot access the original device or account used for MFA enrollment, they can use a recovery code to authenticate.
     *
     * @param {string} id - ID of the user to regenerate a multi-factor authentication recovery code for.
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.NotFoundError}
     *
     * @example
     *     await client.users.regenerateRecoveryCode("id")
     */
    regenerateRecoveryCode(id, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__regenerateRecoveryCode(id, requestOptions));
    }
    __regenerateRecoveryCode(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader() }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : core.fetcher)({
                url: core.url.join((_d = (_c = (yield core.Supplier.get(this._options.baseUrl))) !== null && _c !== void 0 ? _c : (yield core.Supplier.get(this._options.environment))) !== null && _d !== void 0 ? _d : environments.ManagementEnvironment.Default, `users/${core.url.encodePathParam(id)}/recovery-code-regeneration`),
                method: "POST",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1000,
                maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
            });
            if (_response.ok) {
                return {
                    data: _response.body,
                    rawResponse: _response.rawResponse,
                };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Management.BadRequestError(_response.error.body, _response.rawResponse);
                    case 401:
                        throw new Management.UnauthorizedError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Management.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Management.NotFoundError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.ManagementTimeoutError("Timeout exceeded when calling POST /users/{id}/recovery-code-regeneration.");
                case "unknown":
                    throw new errors.ManagementError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Revokes selected resources related to a user (sessions, refresh tokens, ...).
     *
     * @param {string} id - ID of the user.
     * @param {Management.RevokeUserAccessRequestContent} request
     * @param {Users.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Management.BadRequestError}
     * @throws {@link Management.UnauthorizedError}
     * @throws {@link Management.ForbiddenError}
     * @throws {@link Management.TooManyRequestsError}
     *
     * @example
     *     await client.users.revokeAccess("id")
     */
    revokeAccess(id, request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__revokeAccess(id, request, requestOptions));
    }
    __revokeAccess(id_1) {
        return __awaiter(this, arguments, void 0, function* (id, request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders({ Authorization: yield this._getAuthorizationHeader() }), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield ((_b = this._options.fetcher) !== null && _b !== void 0 ? _b : core.fetcher)({
                url: core.url.join((_d = (_c = (yield core.Supplier.get(this._options.baseUrl))) !== null && _c !== void 0 ? _c : (yield core.Supplier.get(this._options.environment))) !== null && _d !== void 0 ? _d : environments.ManagementEnvironment.Default, `users/${core.url.encodePathParam(id)}/revoke-access`),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_g = (_e = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _e !== void 0 ? _e : (_f = this._options) === null || _f === void 0 ? void 0 : _f.timeoutInSeconds) !== null && _g !== void 0 ? _g : 60) * 1000,
                maxRetries: (_h = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _h !== void 0 ? _h : (_j = this._options) === null || _j === void 0 ? void 0 : _j.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_k = this._options) === null || _k === void 0 ? void 0 : _k.fetch,
            });
            if (_response.ok) {
                return { data: undefined, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Management.BadRequestError(_response.error.body, _response.rawResponse);
                    case 401:
                        throw new Management.UnauthorizedError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Management.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 429:
                        throw new Management.TooManyRequestsError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.ManagementError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.ManagementError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new errors.ManagementTimeoutError("Timeout exceeded when calling POST /users/{id}/revoke-access.");
                case "unknown":
                    throw new errors.ManagementError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    _getAuthorizationHeader() {
        return __awaiter(this, void 0, void 0, function* () {
            return `Bearer ${yield core.Supplier.get(this._options.token)}`;
        });
    }
}
