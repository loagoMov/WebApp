import { ManagementClient as FernClient } from "../Client.mjs";
import { TokenProvider } from "./token-provider.mjs";
import { Auth0ClientTelemetry } from "../../lib/middleware/auth0-client-telemetry.mjs";
import { withCustomDomainHeader } from "../request-options.mjs";
/**
 * Auth0 Management API client wrapper.
 *
 * Provides a high-level interface to Auth0's Management API with automatic
 * token management, telemetry, and Auth0-specific configuration.
 *
 * @group Management API
 * @example Using client credentials (client secret)
 * ```typescript
 * const client = new ManagementClient({
 *   domain: 'your-tenant.auth0.com',
 *   clientId: 'your-client-id',
 *   clientSecret: 'your-client-secret'
 * });
 * ```
 *
 * @example Using client credentials (client assertion)
 * ```typescript
 * const client = new ManagementClient({
 *   domain: 'your-tenant.auth0.com',
 *   clientId: 'your-client-id',
 *   clientAssertionSigningKey: 'your-private-key'
 * });
 * ```
 *
 * @example Using existing token
 * ```typescript
 * const client = new ManagementClient({
 *   domain: 'your-tenant.auth0.com',
 *   token: 'your-static-token'  // or () => getAccessToken()
 * });
 * ```
 *
 * @example Using custom domain header
 * ```typescript
 * const client = new ManagementClient({
 *   domain: 'your-tenant.auth0.com',
 *   clientId: 'your-client-id',
 *   clientSecret: 'your-client-secret',
 *   withCustomDomainHeader: 'auth.example.com'  // Auto-applies to whitelisted endpoints
 * });
 * ```
 *
 * @example Using custom fetcher with custom domain header (they work together)
 * ```typescript
 * const client = new ManagementClient({
 *   domain: 'your-tenant.auth0.com',
 *   clientId: 'your-client-id',
 *   clientSecret: 'your-client-secret',
 *   withCustomDomainHeader: 'auth.example.com',  // Custom domain header logic
 *   fetcher: async (args) => {
 *     console.log('Making request:', args.url);  // Custom logging
 *     return fetch(args.url, { ...args });       // Custom fetch implementation
 *   }
 * });
 * ```
 */
export class ManagementClient extends FernClient {
    /**
     * Creates a new Management API client instance.
     *
     * @param _options - Configuration options for the Management Client
     * @group Management API
     */
    constructor(_options) {
        const baseUrl = `https://${_options.domain}/api/v2`;
        const headers = createTelemetryHeaders(_options);
        const token = createTokenSupplier(_options);
        // Temporarily remove fetcher from options to avoid people passing it for now
        delete _options.fetcher;
        delete _options.fetch;
        // Prepare the base client options
        let clientOptions = Object.assign(Object.assign({}, _options), { baseUrl,
            headers,
            token });
        // Apply custom domain header configuration if provided
        if ("withCustomDomainHeader" in _options && _options.withCustomDomainHeader !== undefined) {
            clientOptions = withCustomDomainHeader(_options.withCustomDomainHeader, clientOptions);
        }
        super(clientOptions);
    }
}
/**
 * Type guard to determine if options use token-based authentication.
 *
 * @param _options - The management client configuration options
 * @returns True if the options contain a token property
 * @group Management API
 * @namespace ManagementClient.Utils
 * @private
 */
function isClientOptionsWithToken(_options) {
    return "token" in _options;
}
/**
 * Creates telemetry headers for the Management Client.
 * Adds the Auth0-Client header when telemetry is enabled.
 *
 * @param _options - The management client configuration options
 * @returns Headers object including telemetry information
 * @group Management API
 * @namespace ManagementClient.Utils
 * @private
 */
function createTelemetryHeaders(_options) {
    var _a;
    const headers = Object.assign({}, ((_a = _options.headers) !== null && _a !== void 0 ? _a : {}));
    if (_options.telemetry !== false) {
        const telemetry = new Auth0ClientTelemetry({
            clientInfo: _options.clientInfo,
        });
        const auth0ClientHeader = telemetry.getAuth0ClientHeader();
        if (auth0ClientHeader) {
            headers["Auth0-Client"] = auth0ClientHeader;
        }
    }
    return headers;
}
/**
 * Type guard to check if options contain client secret.
 *
 * @param _options - Client credentials configuration options
 * @returns True if the options contain a clientSecret property
 * @group Management API
 * @namespace ManagementClient.Utils
 * @private
 */
function hasClientSecret(_options) {
    return "clientSecret" in _options;
}
/**
 * Creates a token supplier based on the authentication method.
 * Returns the provided token for token-based auth, or creates a TokenProvider
 * for client credentials (secret or assertion) authentication.
 *
 * @param _options - The management client configuration options
 * @returns A function that returns an access token
 * @group Management API
 * @namespace ManagementClient.Utils
 * @private
 */
function createTokenSupplier(_options) {
    var _a;
    if (isClientOptionsWithToken(_options)) {
        return _options.token;
    }
    // Handle client credentials with proper type checking
    const baseOptions = Object.assign(Object.assign({}, _options), { audience: (_a = _options.audience) !== null && _a !== void 0 ? _a : `https://${_options.domain}/api/v2/`, clientId: _options.clientId, useMTLS: _options.useMTLS });
    if (hasClientSecret(_options)) {
        // Client secret authentication
        const tokenProviderOptions = Object.assign(Object.assign({}, baseOptions), { clientSecret: _options.clientSecret });
        const tokenProvider = new TokenProvider(tokenProviderOptions);
        return () => tokenProvider.getAccessToken();
    }
    else {
        // Client assertion authentication
        const tokenProviderOptions = Object.assign(Object.assign({}, baseOptions), { clientAssertionSigningKey: _options.clientAssertionSigningKey, clientAssertionSigningAlg: _options.clientAssertionSigningAlg });
        const tokenProvider = new TokenProvider(tokenProviderOptions);
        return () => tokenProvider.getAccessToken();
    }
}
